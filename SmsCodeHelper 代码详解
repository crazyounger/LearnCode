## 关于handler 引起内存泄漏解决方式：  
  使用 开源库： WeakHandler(通过对handler和runnable的弱引用的封装)
  
## SharedPreference Editor  两种方式提交：  commit(同步方式提交)  apply(异步方式提交)

## 关于MaterialDesign 使用 布局  CoordinatorLayout   AppBarLayout  Toolbar 

## RecyclerView  ItemDecoration 绘制 shadow 产生阴影效果

## MenuItem   
  在 onCreateOptionsMenu()回调中，可以设置 MenuItem 的展示View(不仅仅是文字展示)
  需要兼容低版本：
  MenuItemCompat.setActionView(menuItem,R.layout.view_switch_compat);
  
## SmsUtils 获取相关短信
  注册广播接收:
  <receiver >
   <action android:name="android.provider.Telephony.SMS_RECEIVED"/>
  </receiver>
  需要相关权限：
  <uses-permission android:name="android.permission.READ_SMS"/>
  <uses-permission android:name="android.permission.WRITE_SMS"/>
  <uses-permission android:name="android.permission.RECEIVE_SMS"/>
 
## 系统Window使用注意细节：
  注册权限：  
  <!-- 系统弹出悬浮窗 -->
  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
  6.0以上系统需要再次确认权限：
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            int hasPermission = checkSelfPermission(Manifest.permission.SYSTEM_ALERT_WINDOW);
            if(hasPermission != PackageManager.PERMISSION_GRANTED){
                requestPermissions(new String[]{Manifest.permission.SYSTEM_ALERT_WINDOW},REQUEST_PERMISSION_CODE);
            }
        }

  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
      if (! Settings.canDrawOverlays(PopupWindowActivity.this)) {
          Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                  Uri.parse("package:" + getPackageName()));
          startActivityForResult(intent,10);
      }
  }
  

## 监听短信相关注意点：
  1 BroadcastReceiver
  2 ContentObserver
  一般使用广播可以收到短信，但是在有些手机上对广播禁用，所以要添加内容监听者，当短信内容发生改变时，做相应的处理
  
  private static final String SMS_RECEIVED_ACTION = Telephony.Sms.Intents.SMS_RECEIVED_ACTION;// 接收到短信时的action
  private static final String SMS_INBOX_URI = "content://sms/inbox";//API level>=23,可直接使用Telephony.Sms.Inbox.CONTENT_URI
  private static final String SMS_URI = "content://sms";//API level>=23,可直接使用Telephony.Sms.CONTENT_URI
  static final String[] PROJECTION = new String[]{
          Telephony.Sms._ID,
          Telephony.Sms.ADDRESS,
          Telephony.Sms.BODY,
          Telephony.Sms.DATE
  };
  
  private ContentObserver mReadSmsObserver = new ContentObserver(new Handler()) {
      @Override
      public void onChange(boolean selfChange) {
          super.onChange(selfChange);
                  Cursor cursor = getContentResolver().query(Uri.parse(SMS_INBOX_URI), PROJECTION,
                  Telephony.Sms.READ + "=?", new String[]{"0"}, Telephony.Sms.Inbox.DEFAULT_SORT_ORDER);
          getSmsCodeFromObserver(cursor);
      }
  };
    
    
   private class ReadSmsCodeReceiver extends BroadcastReceiver {

      @Override
      public void onReceive(Context context, Intent intent) {
          if (intent.getAction().equals(SMS_RECEIVED_ACTION)) {
              getSmsCodeFromReceiver(intent);
          }
      }
  }
  
    /**
     * 注册广播接收者
     */
    private void registerReceiver() {
        IntentFilter filter = new IntentFilter(SMS_RECEIVED_ACTION);
        filter.addAction(SMS_RECEIVED_ACTION);
        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
        registerReceiver(mReadSmsCodeReceiver, filter);
    }

    /**
     * 注册内容观察者
     */
    private void registerObserver() {
        getContentResolver().registerContentObserver(Uri.parse(SMS_URI), true, mReadSmsObserver);
    }
  
  
  
  
  
  
  

